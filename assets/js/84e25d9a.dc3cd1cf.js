"use strict";(self.webpackChunkcyscout=self.webpackChunkcyscout||[]).push([[591],{8831:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>r});var c=n(6070),i=n(1503);const l={},o="SubBasicBlock",t={id:"Classes/SubBasicBlock",title:"SubBasicBlock",description:"Provides the SubBasicBlock class, used for partitioning basic blocks in smaller pieces.",source:"@site/docs/Classes/SubBasicBlock.md",sourceDirName:"Classes",slug:"/Classes/SubBasicBlock",permalink:"/CyScout/Classes/SubBasicBlock",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Specifier",permalink:"/CyScout/Classes/Specifier"},next:{title:"Variable",permalink:"/CyScout/Classes/Variable"}},d={},r=[{value:"Classes",id:"classes",level:2},{value:"SubBasicBlockCutNode",id:"subbasicblockcutnode",level:2},{value:"Methods",id:"methods",level:3},{value:"SubBasicBlockCutNode()",id:"subbasicblockcutnode-1",level:3},{value:"SubBasicBlock",id:"subbasicblock-1",level:2},{value:"Methods",id:"methods-1",level:3},{value:"SubBasicBlock()",id:"subbasicblock-2",level:3},{value:"getBasicBlock()",id:"getbasicblock",level:3},{value:"firstInBB()",id:"firstinbb",level:3},{value:"lastInBB()",id:"lastinbb",level:3},{value:"getRankInBasicBlock(BasicBlock bb)",id:"getrankinbasicblockbasicblock-bb",level:3},{value:"getIndexInBasicBlock(BasicBlock bb)",id:"getindexinbasicblockbasicblock-bb",level:3},{value:"getASuccessor()",id:"getasuccessor",level:3},{value:"getNode(int index)",id:"getnodeint-index",level:3},{value:"outerToInnerIndex(BasicBlock bb, int indexInBB)",id:"outertoinnerindexbasicblock-bb-int-indexinbb",level:3},{value:"getANode()",id:"getanode",level:3},{value:"contains(ControlFlowNode node)",id:"containscontrolflownode-node",level:3},{value:"getAPredecessor()",id:"getapredecessor",level:3},{value:"getATrueSuccessor()",id:"getatruesuccessor",level:3},{value:"getAFalseSuccessor()",id:"getafalsesuccessor",level:3},{value:"getNumberOfNodes()",id:"getnumberofnodes",level:3},{value:"getEnd()",id:"getend",level:3},{value:"getStart()",id:"getstart",level:3},{value:"getEnclosingFunction()",id:"getenclosingfunction",level:3},{value:"Function",id:"function",level:2},{value:"countSubBasicBlocksInBasicBlock(BasicBlock bb)",id:"countsubbasicblocksinbasicblockbasicblock-bb",level:3}];function a(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(s.header,{children:(0,c.jsx)(s.h1,{id:"subbasicblock",children:"SubBasicBlock"})}),"\n",(0,c.jsxs)(s.p,{children:["Provides the ",(0,c.jsx)(s.code,{children:"SubBasicBlock"})," class, used for partitioning basic blocks in smaller pieces."]}),"\n",(0,c.jsx)(s.h2,{id:"classes",children:"Classes"}),"\n",(0,c.jsxs)(s.ul,{children:["\n",(0,c.jsx)(s.li,{children:(0,c.jsx)(s.a,{href:"#subbasicblockcutnode",children:"SubBasicBlockCutNode"})}),"\n",(0,c.jsx)(s.li,{children:(0,c.jsx)(s.a,{href:"#subbasicblock",children:"SubBasicBlock"})}),"\n"]}),"\n",(0,c.jsx)(s.h2,{id:"subbasicblockcutnode",children:"SubBasicBlockCutNode"}),"\n",(0,c.jsxs)(s.p,{children:["An abstract class that directs where in the control-flow graph a new ",(0,c.jsx)(s.code,{children:"SubBasicBlock"})," must start. If a ",(0,c.jsx)(s.code,{children:"ControlFlowNode"})," is an instance of this class, that node is guaranteed to be the first node in a ",(0,c.jsx)(s.code,{children:"SubBasicBlock"}),"."]}),"\n",(0,c.jsxs)(s.p,{children:["If multiple libraries use the ",(0,c.jsx)(s.code,{children:"SubBasicBlock"})," library, basic blocks may be split in more places than either library expects, but nothing should break as a direct result of that."]}),"\n",(0,c.jsx)(s.h3,{id:"methods",children:"Methods"}),"\n",(0,c.jsxs)(s.ul,{children:["\n",(0,c.jsx)(s.li,{children:(0,c.jsx)(s.a,{href:"#subbasicblock-1",children:"SubBasicBlockCutNode()"})}),"\n"]}),"\n",(0,c.jsx)(s.h3,{id:"subbasicblockcutnode-1",children:"SubBasicBlockCutNode()"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{children:"SubBasicBlockCutNode() {\n    exists(this.getBasicBlock())\n  }\n"})}),"\n",(0,c.jsxs)(s.p,{children:["Some control-flow nodes are not in any basic block. This includes\n",(0,c.jsx)(s.code,{children:"Conversion"}),"s, expressions that are evaluated at compile time, default arguments, and ",(0,c.jsx)(s.code,{children:"Function"}),"s without implementation."]}),"\n",(0,c.jsx)(s.h2,{id:"subbasicblock-1",children:"SubBasicBlock"}),"\n",(0,c.jsxs)(s.p,{children:["A block that can be smaller than or equal to a ",(0,c.jsx)(s.code,{children:"BasicBlock"}),". Use this class when ",(0,c.jsx)(s.code,{children:"ControlFlowNode"})," is too fine-grained and ",(0,c.jsx)(s.code,{children:"BasicBlock"})," too\ncoarse-grained. Their successor graph is like that of basic blocks, except that the blocks are split up with an extra edge right before any instance of the abstract class ",(0,c.jsx)(s.code,{children:"SubBasicBlockCutNode"}),". Users of this library must therefore extend ",(0,c.jsx)(s.code,{children:"SubBasicBlockCutNode"})," to direct where basic blocks will be\nsplit up."]}),"\n",(0,c.jsx)(s.h3,{id:"methods-1",children:"Methods"}),"\n",(0,c.jsxs)(s.ul,{children:["\n",(0,c.jsx)(s.li,{children:(0,c.jsx)(s.a,{href:"#subbasicblock-2",children:"SubBasicBlock()"})}),"\n",(0,c.jsx)(s.li,{children:(0,c.jsx)(s.a,{href:"#getbasicblock",children:"getBasicBlock()"})}),"\n",(0,c.jsx)(s.li,{children:(0,c.jsx)(s.a,{href:"#firstinbb",children:"firstInBB()"})}),"\n",(0,c.jsx)(s.li,{children:(0,c.jsx)(s.a,{href:"#lastinbb",children:"lastInBB()"})}),"\n",(0,c.jsx)(s.li,{children:(0,c.jsx)(s.a,{href:"#getrankinbasicblockbasicblock-bb",children:"getRankInBasicBlock(BasicBlock bb)"})}),"\n",(0,c.jsx)(s.li,{children:(0,c.jsx)(s.a,{href:"#getindexinbasicblockbasicblock-bb",children:"getIndexInBasicBlock(BasicBlock bb)"})}),"\n",(0,c.jsx)(s.li,{children:(0,c.jsx)(s.a,{href:"#getasuccessor",children:"getASuccessor()"})}),"\n",(0,c.jsx)(s.li,{children:(0,c.jsx)(s.a,{href:"#getnodeint-index",children:"getNode(int index)"})}),"\n",(0,c.jsx)(s.li,{children:(0,c.jsx)(s.a,{href:"#outertoinnerindexbasicblock-bb-int-indexinbb",children:"outerToInnerIndex(BasicBlock bb, int indexInBB)"})}),"\n",(0,c.jsx)(s.li,{children:(0,c.jsx)(s.a,{href:"#getanode",children:"getANode()"})}),"\n",(0,c.jsx)(s.li,{children:(0,c.jsx)(s.a,{href:"#containscontrolflownode-node",children:"contains(ControlFlowNode node)"})}),"\n",(0,c.jsx)(s.li,{children:(0,c.jsx)(s.a,{href:"#getapredecessor",children:"getAPredecessor()"})}),"\n",(0,c.jsx)(s.li,{children:(0,c.jsx)(s.a,{href:"#getatruesuccessor",children:"getATrueSuccessor()"})}),"\n",(0,c.jsx)(s.li,{children:(0,c.jsx)(s.a,{href:"#getafalsesuccessor",children:"getAFalseSuccessor()"})}),"\n",(0,c.jsx)(s.li,{children:(0,c.jsx)(s.a,{href:"#getnumberofnodes",children:"getNumberOfNodes()"})}),"\n",(0,c.jsx)(s.li,{children:(0,c.jsx)(s.a,{href:"#getend",children:"getEnd()"})}),"\n",(0,c.jsx)(s.li,{children:(0,c.jsx)(s.a,{href:"#getstart",children:"getStart()"})}),"\n",(0,c.jsx)(s.li,{children:(0,c.jsx)(s.a,{href:"#getenclosingfunction",children:"getEnclosingFunction()"})}),"\n"]}),"\n",(0,c.jsx)(s.h3,{id:"subbasicblock-2",children:"SubBasicBlock()"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{children:"SubBasicBlock() {\n    this instanceof BasicBlock\n    or\n    this instanceof SubBasicBlockCutNode\n}\n"})}),"\n",(0,c.jsx)(s.h3,{id:"getbasicblock",children:"getBasicBlock()"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{children:"BasicBlock getBasicBlock() { result = this.(ControlFlowNode).getBasicBlock()}\n"})}),"\n",(0,c.jsxs)(s.p,{children:["Gets the basic block in which this ",(0,c.jsx)(s.code,{children:"SubBasicBlock"})," is contained."]}),"\n",(0,c.jsx)(s.h3,{id:"firstinbb",children:"firstInBB()"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{children:"predicate firstInBB() { this.getRankInBasicBlock(_) = 1 }\n"})}),"\n",(0,c.jsxs)(s.p,{children:["Holds if this ",(0,c.jsx)(s.code,{children:"SubBasicBlock"})," comes first in its basic block. This is the only condition under which a ",(0,c.jsx)(s.code,{children:"SubBasicBlock"})," may have multiple\npredecessors."]}),"\n",(0,c.jsx)(s.h3,{id:"lastinbb",children:"lastInBB()"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{children:"predicate lastInBB() {\n    exists(BasicBlock bb | this.getRankInBasicBlock(bb) = countSubBasicBlocksInBasicBlock(bb))\n}\n"})}),"\n",(0,c.jsxs)(s.p,{children:["Holds if this ",(0,c.jsx)(s.code,{children:"SubBasicBlock"})," comes last in its basic block. This is the only condition under which a ",(0,c.jsx)(s.code,{children:"SubBasicBlock"})," may have multiple successors."]}),"\n",(0,c.jsx)(s.h3,{id:"getrankinbasicblockbasicblock-bb",children:"getRankInBasicBlock(BasicBlock bb)"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{children:"int getRankInBasicBlock(BasicBlock bb) {\n    exists(int thisIndexInBB |\n      thisIndexInBB = this.getIndexInBasicBlock(bb) and\n      thisIndexInBB = rank[result](int i | i = any(SubBasicBlock n).getIndexInBasicBlock(bb))\n    )\n}\n"})}),"\n",(0,c.jsxs)(s.p,{children:["Gets the (1-based) rank of this ",(0,c.jsx)(s.code,{children:"SubBasicBlock"})," among the other ",(0,c.jsx)(s.code,{children:"SubBasicBlock"}),"s in its containing basic block ",(0,c.jsx)(s.code,{children:"bb"}),", where ",(0,c.jsx)(s.code,{children:"bb"})," is equal to ",(0,c.jsx)(s.code,{children:"getBasicBlock()"}),"."]}),"\n",(0,c.jsx)(s.h3,{id:"getindexinbasicblockbasicblock-bb",children:"getIndexInBasicBlock(BasicBlock bb)"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{children:"private int getIndexInBasicBlock(BasicBlock bb) { this = bb.getNode(result) }\n"})}),"\n",(0,c.jsx)(s.h3,{id:"getasuccessor",children:"getASuccessor()"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{children:"SubBasicBlock getASuccessor() {\n    this.lastInBB() and\n    result = this.getBasicBlock().getASuccessor()\n    or\n    exists(BasicBlock bb | result.getRankInBasicBlock(bb) = this.getRankInBasicBlock(bb) + 1)\n}\n"})}),"\n",(0,c.jsxs)(s.p,{children:["Gets a successor in the control-flow graph of ",(0,c.jsx)(s.code,{children:"SubBasicBlock"}),"s."]}),"\n",(0,c.jsx)(s.h3,{id:"getnodeint-index",children:"getNode(int index)"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{children:"ControlFlowNode getNode(int index) {\n    exists(BasicBlock bb |\n      exists(int outerIndex |\n        result = bb.getNode(outerIndex) and\n        index = this.outerToInnerIndex(bb, outerIndex)\n      )\n    )\n}\n"})}),"\n",(0,c.jsxs)(s.p,{children:["Gets the ",(0,c.jsx)(s.code,{children:"index"}),"th control-flow node in this ",(0,c.jsx)(s.code,{children:"SubBasicBlock"}),". Indexes start from 0, and the node at index 0 always exists and compares equal to ",(0,c.jsx)(s.code,{children:"this"}),"."]}),"\n",(0,c.jsx)(s.h3,{id:"outertoinnerindexbasicblock-bb-int-indexinbb",children:"outerToInnerIndex(BasicBlock bb, int indexInBB)"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{children:"private int outerToInnerIndex(BasicBlock bb, int indexInBB) {\n    indexInBB = result + this.getIndexInBasicBlock(bb) and\n    result = [0 .. this.getNumberOfNodes() - 1]\n}\n"})}),"\n",(0,c.jsxs)(s.p,{children:["Gets the index of the node in this ",(0,c.jsx)(s.code,{children:"SubBasicBlock"})," that has ",(0,c.jsx)(s.code,{children:"indexInBB"})," in ",(0,c.jsx)(s.code,{children:"bb"}),", where ",(0,c.jsx)(s.code,{children:"bb"})," is equal to ",(0,c.jsx)(s.code,{children:"getBasicBlock()"}),"."]}),"\n",(0,c.jsxs)(s.p,{children:["This predicate is factored out of ",(0,c.jsx)(s.code,{children:"getNode"})," to ensure a good join order.\nIt's sensitive to bad magic, so it has ",(0,c.jsx)(s.code,{children:"pragma[nomagic]"})," on it. For example, it can get very slow if ",(0,c.jsx)(s.code,{children:"getNode"})," is pragma[nomagic], which could mean it might get very slow if ",(0,c.jsx)(s.code,{children:"getNode"})," is used in the wrong context."]}),"\n",(0,c.jsx)(s.h3,{id:"getanode",children:"getANode()"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{children:"ControlFlowNode getANode() { result = this.getNode(_) }\n"})}),"\n",(0,c.jsxs)(s.p,{children:["Gets a control-flow node in this ",(0,c.jsx)(s.code,{children:"SubBasicBlock"}),"."]}),"\n",(0,c.jsx)(s.h3,{id:"containscontrolflownode-node",children:"contains(ControlFlowNode node)"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{children:"predicate contains(ControlFlowNode node) { node = this.getANode() }\n"})}),"\n",(0,c.jsxs)(s.p,{children:["Holds if ",(0,c.jsx)(s.code,{children:"this"})," contains ",(0,c.jsx)(s.code,{children:"node"}),"."]}),"\n",(0,c.jsx)(s.h3,{id:"getapredecessor",children:"getAPredecessor()"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{children:"SubBasicBlock getAPredecessor() { result.getASuccessor() = this }\n"})}),"\n",(0,c.jsxs)(s.p,{children:["Gets a predecessor in the control-flow graph of ",(0,c.jsx)(s.code,{children:"SubBasicBlock"}),"s."]}),"\n",(0,c.jsx)(s.h3,{id:"getatruesuccessor",children:"getATrueSuccessor()"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{children:"SubBasicBlock getATrueSuccessor() {\n    this.lastInBB() and\n    result = this.getBasicBlock().getATrueSuccessor()\n}\n"})}),"\n",(0,c.jsxs)(s.p,{children:["Gets a node such that the control-flow edge ",(0,c.jsx)(s.code,{children:"(this, result)"})," may be taken when the final node of this ",(0,c.jsx)(s.code,{children:"SubBasicBlock"})," is a conditional expression and evaluates to true."]}),"\n",(0,c.jsx)(s.h3,{id:"getafalsesuccessor",children:"getAFalseSuccessor()"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{children:"SubBasicBlock getAFalseSuccessor() {\n    this.lastInBB() and\n    result = this.getBasicBlock().getAFalseSuccessor()\n}\n"})}),"\n",(0,c.jsxs)(s.p,{children:["Gets a node such that the control-flow edge ",(0,c.jsx)(s.code,{children:"(this, result)"})," may be taken when the final node of this ",(0,c.jsx)(s.code,{children:"SubBasicBlock"})," is a conditional expression and evaluates to false."]}),"\n",(0,c.jsx)(s.h3,{id:"getnumberofnodes",children:"getNumberOfNodes()"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{children:"int getNumberOfNodes() {\n    exists(BasicBlock bb |\n      if this.lastInBB()\n      then result = bb.length() - this.getIndexInBasicBlock(bb)\n      else result = this.getASuccessor().getIndexInBasicBlock(bb) - this.getIndexInBasicBlock(bb)\n    )\n}\n"})}),"\n",(0,c.jsxs)(s.p,{children:["Gets the number of control-flow nodes in this ",(0,c.jsx)(s.code,{children:"SubBasicBlock"}),". There is always at least one."]}),"\n",(0,c.jsx)(s.h3,{id:"getend",children:"getEnd()"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{children:"ControlFlowNode getEnd() { result = this.getNode(this.getNumberOfNodes() - 1) }\n"})}),"\n",(0,c.jsxs)(s.p,{children:["Gets the last control-flow node in this ",(0,c.jsx)(s.code,{children:"SubBasicBlock"}),"."]}),"\n",(0,c.jsx)(s.h3,{id:"getstart",children:"getStart()"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{children:"ControlFlowNode getStart() { result = this }\n"})}),"\n",(0,c.jsxs)(s.p,{children:["Gets the first control-flow node in this ",(0,c.jsx)(s.code,{children:"SubBasicBlock"}),"."]}),"\n",(0,c.jsx)(s.h3,{id:"getenclosingfunction",children:"getEnclosingFunction()"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{children:"Function getEnclosingFunction() { result = this.getStart().getControlFlowScope() }\n"})}),"\n",(0,c.jsxs)(s.p,{children:["Gets the function that contains this ",(0,c.jsx)(s.code,{children:"SubBasicBlock"}),"."]}),"\n",(0,c.jsx)(s.h2,{id:"function",children:"Function"}),"\n",(0,c.jsxs)(s.ul,{children:["\n",(0,c.jsx)(s.li,{children:(0,c.jsx)(s.a,{href:"#countsubbasicblocksinbasicblockbasicblock-bb",children:"countSubBasicBlocksInBasicBlock(BasicBlock bb)"})}),"\n"]}),"\n",(0,c.jsx)(s.h3,{id:"countsubbasicblocksinbasicblockbasicblock-bb",children:"countSubBasicBlocksInBasicBlock(BasicBlock bb)"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{children:"private int countSubBasicBlocksInBasicBlock(BasicBlock bb) {\n  result = strictcount(SubBasicBlock sbb | sbb.getBasicBlock() = bb)\n}\n"})}),"\n",(0,c.jsxs)(s.p,{children:["Gets the number of ",(0,c.jsx)(s.code,{children:"SubBasicBlock"}),"s in the given basic block."]})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,c.jsx)(s,{...e,children:(0,c.jsx)(a,{...e})}):a(e)}},1503:(e,s,n)=>{n.d(s,{R:()=>o,x:()=>t});var c=n(758);const i={},l=c.createContext(i);function o(e){const s=c.useContext(l);return c.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function t(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),c.createElement(l.Provider,{value:s},e.children)}}}]);