"use strict";(self.webpackChunkcodeql_research=self.webpackChunkcodeql_research||[]).push([[309],{6575:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>t,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var c=i(6070),s=i(1503);const o={},l="BasicBlock",r={id:"Classes/BasicBlock",title:"BasicBlock",description:"Provides a library for reasoning about control flow at the granularity of basic blocks. This is usually much more efficient than reasoning directly at the level of ControlFlowNodes.",source:"@site/docs/Classes/BasicBlock.md",sourceDirName:"Classes",slug:"/Classes/BasicBlock",permalink:"/docs/Classes/BasicBlock",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Classes/BasicBlock.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Access",permalink:"/docs/Classes/Access"},next:{title:"Block Statement",permalink:"/docs/Classes/Block"}},t={},d=[{value:"Module, Classes and Predicate",id:"module-classes-and-predicate",level:2},{value:"Cached",id:"cached",level:2},{value:"Predicates",id:"predicates",level:3},{value:"basic_block_entry_node(ControlFlowNode node)",id:"basic_block_entry_nodecontrolflownode-node",level:3},{value:"non_primitive_basic_block_entry_node(ControlFlowNode node",id:"non_primitive_basic_block_entry_nodecontrolflownode-node",level:3},{value:"equalsPrimitiveBasicBlock(BasicBlock bb)",id:"equalsprimitivebasicblockbasicblock-bb",level:3},{value:"basic_block_member(ControlFlowNode node, BasicBlock bb, int pos)",id:"basic_block_membercontrolflownode-node-basicblock-bb-int-pos",level:3},{value:"predicate non_primitive_basic_block_member(ControlFlowNode node, BasicBlock bb, int pos)",id:"predicate-non_primitive_basic_block_membercontrolflownode-node-basicblock-bb-int-pos",level:3},{value:"bb_length(BasicBlock bb)",id:"bb_lengthbasicblock-bb",level:3},{value:"bb_successor_cached(BasicBlock pred, BasicBlock succ)",id:"bb_successor_cachedbasicblock-pred-basicblock-succ",level:3},{value:"BasicBlock",id:"basicblock-1",level:2},{value:"Methods and predicates",id:"methods-and-predicates",level:3},{value:"BasicBlock()",id:"basicblock-2",level:3},{value:"contains(ControlFlowNode node)",id:"containscontrolflownode-node",level:3},{value:"getNode(int pos)",id:"getnodeint-pos",level:3},{value:"getANode()",id:"getanode",level:3},{value:"getASuccessor()",id:"getasuccessor",level:3},{value:"getAPredecessor()",id:"getapredecessor",level:3},{value:"getATrueSuccessor()",id:"getatruesuccessor",level:3},{value:"getAFalseSuccessor()",id:"getafalsesuccessor",level:3},{value:"getEnd()",id:"getend",level:3},{value:"getStart()",id:"getstart",level:3},{value:"length()",id:"length",level:3},{value:"hasLocationInfo(string filepath, int startline, int startcolumn, int endline, int endcolumn)",id:"haslocationinfostring-filepath-int-startline-int-startcolumn-int-endline-int-endcolumn",level:3},{value:"hasLocationInfoInternal(string file, int line, int col, string endf, int endl, int endc)",id:"haslocationinfointernalstring-file-int-line-int-col-string-endf-int-endl-int-endc",level:3},{value:"getEnclosingFunction()",id:"getenclosingfunction",level:3},{value:"inLoop()",id:"inloop",level:3},{value:"isReachable()",id:"isreachable",level:3},{value:"isUnreachable()",id:"isunreachable",level:3},{value:"EntryBasicBlock",id:"entrybasicblock",level:2},{value:"EntryBasicBlock()",id:"entrybasicblock-1",level:3},{value:"ExitBasicBlock",id:"exitbasicblock",level:2},{value:"ExitBasicBlock(",id:"exitbasicblock-1",level:3},{value:"unreachable(ControlFlowNode n)",id:"unreachablecontrolflownode-n",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.header,{children:(0,c.jsx)(n.h1,{id:"basicblock",children:"BasicBlock"})}),"\n",(0,c.jsxs)(n.p,{children:["Provides a library for reasoning about control flow at the granularity of basic blocks. This is usually much more efficient than reasoning directly at the level of ",(0,c.jsx)(n.code,{children:"ControlFlowNode"}),"s."]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"BasicBlock"}),"s are refinements of ",(0,c.jsx)(n.code,{children:"PrimitiveBasicBlock"}),"s, taking\nimpossible CFG edges into account (using the ",(0,c.jsx)(n.code,{children:"successors_adapted"}),"\nrelation). The refinement manifests itself in two changes:"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["The successor relation on ",(0,c.jsx)(n.code,{children:"BasicBlock"}),"s uses ",(0,c.jsx)(n.code,{children:"successors_adapted"}),"\n(instead of ",(0,c.jsx)(n.code,{children:"successors_extended"})," used by ",(0,c.jsx)(n.code,{children:"PrimitiveBasicBlock"}),"s). Consequently, some edges between ",(0,c.jsx)(n.code,{children:"BasicBlock"}),"s may be removed. Example:"]}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"x = 1;      // s1\nif (true) { // s2\n  x = 2;    // s3\n} else {\n  x = 3;    // s4\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["The ",(0,c.jsx)(n.code,{children:"BasicBlock"})," successor edge from the basic block containing ",(0,c.jsx)(n.code,{children:"s1"})," and ",(0,c.jsx)(n.code,{children:"s2"})," to the basic block containing ",(0,c.jsx)(n.code,{children:"s4"})," is removed."]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"PrimitiveBasicBlock"}),"s may be split up into two or more\n",(0,c.jsx)(n.code,{children:"BasicBlock"}),"s: Internal nodes of ",(0,c.jsx)(n.code,{children:"PrimitiveBasicBlock"}),"s whose\npredecessor edges have been removed (unreachable code) will be entry points of new ",(0,c.jsx)(n.code,{children:"BasicBlock"}),"s. Consequently, each entry point of a ",(0,c.jsx)(n.code,{children:"PrimitiveBasicBlock"})," will also be an entry point of a ",(0,c.jsx)(n.code,{children:"BasicBlock"}),", but the converse does not necessarily hold. Example:"]}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"x = 1;   // s5\nabort(); // s6\nx = 2;   // s7\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"s5"}),"-",(0,c.jsx)(n.code,{children:"s7"})," belong to the same ",(0,c.jsx)(n.code,{children:"PrimitiveBasicBlock"}),", but the CFG edge from ",(0,c.jsx)(n.code,{children:"s6"})," to ",(0,c.jsx)(n.code,{children:"s7"})," is impossible, so ",(0,c.jsx)(n.code,{children:"s7"})," will be the entry point of its own (unreachable) ",(0,c.jsx)(n.code,{children:"BasicBlock"}),"."]}),"\n",(0,c.jsxs)(n.p,{children:["Note that, although possible, two or more ",(0,c.jsx)(n.code,{children:"PrimitiveBasicBlock"}),"s are never merged to one ",(0,c.jsx)(n.code,{children:"BasicBlock"}),": Consider the first example above; it would be possible to define a single ",(0,c.jsx)(n.code,{children:"BasicBlock"})," consisting of ",(0,c.jsx)(n.code,{children:"s1"}),"-",(0,c.jsx)(n.code,{children:"s3"}),", however, the result would be counter-intuitive."]}),"\n",(0,c.jsx)(n.h2,{id:"module-classes-and-predicate",children:"Module, Classes and Predicate"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#cached",children:"Cached"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#basicblock-1",children:"BasicBlock"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#entrybasicblock",children:"EntryBasicBlock"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#exitbasicblock",children:"ExitBasicBlock"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#unreachablecontrolflownode-n",children:"unreachable(ControlFlowNode n)"})}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"cached",children:"Cached"}),"\n",(0,c.jsx)(n.h3,{id:"predicates",children:"Predicates"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#basic_block_entry_nodecontrolflownode-node",children:"basic_block_entry_node(ControlFlowNode node)"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#non_primitive_basic_block_entry_nodecontrolflownode-node",children:"non_primitive_basic_block_entry_node(ControlFlowNode node)"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#equalsprimitivebasicblockbasicblock-bb",children:"equalsPrimitiveBasicBlock(BasicBlock bb)"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#basic_block_membercontrolflownode-node-basicblock-bb-int-pos",children:"basic_block_member(ControlFlowNode node, BasicBlock bb, int pos)"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#non_primitive_basic_block_entry_nodecontrolflownode-node",children:"non_primitive_basic_block_member(ControlFlowNode node, BasicBlock bb, int pos)"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#bb_lengthbasicblock-bb",children:"bb_length(BasicBlock bb)"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#bb_successor_cachedbasicblock-pred-basicblock-succ",children:"bb_successor_cached(BasicBlock pred, BasicBlock succ)"})}),"\n"]}),"\n",(0,c.jsx)(n.h3,{id:"basic_block_entry_nodecontrolflownode-node",children:"basic_block_entry_node(ControlFlowNode node)"}),"\n",(0,c.jsxs)(n.p,{children:["Any node that is the entry point of a primitive basic block is\nalso the entry point of a basic block. In addition, all nodes\nwith a primitive successor, where the predecessor has been pruned\n(that is, ",(0,c.jsx)(n.code,{children:"getAPredecessor()"})," does not exist while a predecessor\nusing the primitive ",(0,c.jsx)(n.code,{children:"successors_extended"})," relation does exist), is also considered a basic block entry node."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"predicate basic_block_entry_node(ControlFlowNode node) {\n    primitive_basic_block_entry_node(node) or\n    non_primitive_basic_block_entry_node(node)\n  }\n"})}),"\n",(0,c.jsx)(n.h3,{id:"non_primitive_basic_block_entry_nodecontrolflownode-node",children:"non_primitive_basic_block_entry_node(ControlFlowNode node"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"private predicate non_primitive_basic_block_entry_node(ControlFlowNode node) {\n    not primitive_basic_block_entry_node(node) and\n    not exists(node.getAPredecessor()) and\n    successors_extended(node, _)\n}\n"})}),"\n",(0,c.jsx)(n.h3,{id:"equalsprimitivebasicblockbasicblock-bb",children:"equalsPrimitiveBasicBlock(BasicBlock bb)"}),"\n",(0,c.jsxs)(n.p,{children:["Holds if basic block ",(0,c.jsx)(n.code,{children:"bb"})," equals a primitive basic block."]}),"\n",(0,c.jsx)(n.p,{children:"There are two situations in which this isnot* the case:"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["Either the entry node of ",(0,c.jsx)(n.code,{children:"bb"})," does not correspond to an\nentry node of a primitive basic block, or"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsx)(n.p,{children:"The primitive basic block with the same entry node contains\na (non-entry) node which is the entry node of a non-primitive\nbasic block (that is, the primitive basic block has been split\nup)."}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["This predicate is used for performance optimization only:\nWhenever a ",(0,c.jsx)(n.code,{children:"BasicBlock"})," equals a ",(0,c.jsx)(n.code,{children:"PrimitiveBasicBlock"}),", we can\nreuse predicates already computed for ",(0,c.jsx)(n.code,{children:"PrimitiveBasicBlocks"}),"."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"private predicate equalsPrimitiveBasicBlock(BasicBlock bb) {\n    primitive_basic_block_entry_node(bb) and\n    not exists(int i |\n      i > 0 and\n      non_primitive_basic_block_entry_node(bb.(PrimitiveBasicBlock).getNode(i))\n    )\n  }\n"})}),"\n",(0,c.jsx)(n.h3,{id:"basic_block_membercontrolflownode-node-basicblock-bb-int-pos",children:"basic_block_member(ControlFlowNode node, BasicBlock bb, int pos)"}),"\n",(0,c.jsxs)(n.p,{children:["Holds if ",(0,c.jsx)(n.code,{children:"node"})," is the ",(0,c.jsx)(n.code,{children:"pos"}),"th control-flow node in basic block ",(0,c.jsx)(n.code,{children:"bb"}),"."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"cached predicate basic_block_member(ControlFlowNode node, BasicBlock bb, int pos) {\n    equalsPrimitiveBasicBlock(bb) and primitive_basic_block_member(node, bb, pos) // reuse already computed relation\n    or\n    non_primitive_basic_block_member(node, bb, pos)\n}\n"})}),"\n",(0,c.jsx)(n.h3,{id:"predicate-non_primitive_basic_block_membercontrolflownode-node-basicblock-bb-int-pos",children:"predicate non_primitive_basic_block_member(ControlFlowNode node, BasicBlock bb, int pos)"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"private predicate non_primitive_basic_block_member(ControlFlowNode node, BasicBlock bb, int pos) {\n    not equalsPrimitiveBasicBlock(bb) and node = bb and pos = 0\n    or\n    not node instanceof BasicBlock and\n    exists(ControlFlowNode pred | successors_extended(pred, node) |\n      non_primitive_basic_block_member(pred, bb, pos - 1)\n    )\n}\n"})}),"\n",(0,c.jsx)(n.h3,{id:"bb_lengthbasicblock-bb",children:"bb_length(BasicBlock bb)"}),"\n",(0,c.jsxs)(n.p,{children:["Gets the number of control-flow nodes in the basic block ",(0,c.jsx)(n.code,{children:"bb"}),"./"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"cached int bb_length(BasicBlock bb) {\n    if equalsPrimitiveBasicBlock(bb)\n    then result = bb.(PrimitiveBasicBlock).length() // reuse already computed relation\n    else result = strictcount(ControlFlowNode node | basic_block_member(node, bb, _))\n}\n"})}),"\n",(0,c.jsx)(n.h3,{id:"bb_successor_cachedbasicblock-pred-basicblock-succ",children:"bb_successor_cached(BasicBlock pred, BasicBlock succ)"}),"\n",(0,c.jsx)(n.p,{children:"Successor relation for basic blocks."}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"cached predicate bb_successor_cached(BasicBlock pred, BasicBlock succ) {\n    exists(ControlFlowNode last |\n      basic_block_member(last, pred, bb_length(pred) - 1) and\n      last.getASuccessor() = succ\n    )\n}\n"})}),"\n",(0,c.jsx)(n.h2,{id:"basicblock-1",children:"BasicBlock"}),"\n",(0,c.jsx)(n.p,{children:"A basic block in the Solidity control-flow graph."}),"\n",(0,c.jsx)(n.p,{children:"A basic block is a simple sequence of control-flow nodes,\nconnected to each other and nothing else:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"   A - B - C - D  ABCD is a basic block\n"})}),"\n",(0,c.jsx)(n.p,{children:"Any incoming or outgoing edges break the block into two:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"   A - B > C - D  AB is a basic block and CD is a basic block (C has two incoming edges)\n\n\n   A - B < C - D  AB is a basic block and CD is a basic block (B has two outgoing edges)\n"})}),"\n",(0,c.jsx)(n.h3,{id:"methods-and-predicates",children:"Methods and predicates"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#basicblock-2",children:"BasicBlock"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#containscontrolflownode-node",children:"contains"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#getnodeint-pos",children:"getNode"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#getanode",children:"getANode"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#getasuccessor",children:"getASuccessor"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#getapredecessor",children:"getAPredecessor"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#getatruesuccessor",children:"getATrueSuccessor"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#getafalsesuccessor",children:"getAFalseSuccessor"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#getend",children:"getEnd"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#getstart",children:"getStart"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#length",children:"length"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#haslocationinfostring-filepath-int-startline-int-startcolumn-int-endline-int-endcolumn",children:"hasLocationInfo"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#haslocationinfointernalstring-file-int-line-int-col-string-endf-int-endl-int-endc",children:"hasLocationInfoInternal"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#getenclosingfunction",children:"getEnclosingFunction"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#inloop",children:"inLoop"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#isreachable",children:"isReachable"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#isunreachable",children:"isUnreachable"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"#unreachablecontrolflownode-n",children:"unreachable"})}),"\n"]}),"\n",(0,c.jsx)(n.h3,{id:"basicblock-2",children:"BasicBlock()"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"BasicBlock() { basic_block_entry_node(this) }\n"})}),"\n",(0,c.jsx)(n.h3,{id:"containscontrolflownode-node",children:"contains(ControlFlowNode node)"}),"\n",(0,c.jsxs)(n.p,{children:["Holds if this basic block contains ",(0,c.jsx)(n.code,{children:"node"}),"."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"predicate contains(ControlFlowNode node) { basic_block_member(node, this, _) }\n"})}),"\n",(0,c.jsx)(n.h3,{id:"getnodeint-pos",children:"getNode(int pos)"}),"\n",(0,c.jsxs)(n.p,{children:["Gets the ",(0,c.jsx)(n.code,{children:"ControlFlowNode"})," at position ",(0,c.jsx)(n.code,{children:"pos"})," in this basic block."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"ControlFlowNode getNode(int pos) { basic_block_member(result, this, pos) }\n"})}),"\n",(0,c.jsx)(n.h3,{id:"getanode",children:"getANode()"}),"\n",(0,c.jsxs)(n.p,{children:["Gets a ",(0,c.jsx)(n.code,{children:"ControlFlowNode"})," in this basic block."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"ControlFlowNode getANode() { basic_block_member(result, this, _) }\n"})}),"\n",(0,c.jsx)(n.h3,{id:"getasuccessor",children:"getASuccessor()"}),"\n",(0,c.jsxs)(n.p,{children:["Gets a ",(0,c.jsx)(n.code,{children:"BasicBlock"})," that is a direct successor of this basic block."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"BasicBlock getASuccessor() { bb_successor(this, result) }\n"})}),"\n",(0,c.jsx)(n.h3,{id:"getapredecessor",children:"getAPredecessor()"}),"\n",(0,c.jsxs)(n.p,{children:["Gets a ",(0,c.jsx)(n.code,{children:"BasicBlock"})," that is a direct predecessor of this basic block."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"BasicBlock getAPredecessor() { bb_successor(result, this) }\n"})}),"\n",(0,c.jsx)(n.h3,{id:"getatruesuccessor",children:"getATrueSuccessor()"}),"\n",(0,c.jsxs)(n.p,{children:["Gets a ",(0,c.jsx)(n.code,{children:"BasicBlock"})," such that the control-flow edge ",(0,c.jsx)(n.code,{children:"(this, result)"})," may be taken when the outgoing edge of this basic block is an expression that is true."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"BasicBlock getATrueSuccessor() { result.getStart() = this.getEnd().getATrueSuccessor() }\n"})}),"\n",(0,c.jsx)(n.h3,{id:"getafalsesuccessor",children:"getAFalseSuccessor()"}),"\n",(0,c.jsxs)(n.p,{children:["Gets a ",(0,c.jsx)(n.code,{children:"BasicBlock"})," such that the control-flow edge ",(0,c.jsx)(n.code,{children:"(this, result)"})," may be taken when the outgoing edge of this basic block is an expression that is false."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"BasicBlock getAFalseSuccessor() { result.getStart() = this.getEnd().getAFalseSuccessor() }\n"})}),"\n",(0,c.jsx)(n.h3,{id:"getend",children:"getEnd()"}),"\n",(0,c.jsxs)(n.p,{children:["Gets the final ",(0,c.jsx)(n.code,{children:"ControlFlowNode"})," of this basic block."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"ControlFlowNode getEnd() { basic_block_member(result, this, bb_length(this) - 1) }\n"})}),"\n",(0,c.jsx)(n.h3,{id:"getstart",children:"getStart()"}),"\n",(0,c.jsxs)(n.p,{children:["Gets the first ",(0,c.jsx)(n.code,{children:"ControlFlowNode"})," of this basic block."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"ControlFlowNode getStart() { result = this }\n"})}),"\n",(0,c.jsx)(n.h3,{id:"length",children:"length()"}),"\n",(0,c.jsxs)(n.p,{children:["Gets the number of ",(0,c.jsx)(n.code,{children:"ControlFlowNode"}),"s in this basic block."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"int length() { result = bb_length(this) }\n"})}),"\n",(0,c.jsx)(n.h3,{id:"haslocationinfostring-filepath-int-startline-int-startcolumn-int-endline-int-endcolumn",children:"hasLocationInfo(string filepath, int startline, int startcolumn, int endline, int endcolumn)"}),"\n",(0,c.jsxs)(n.p,{children:["Holds if this element is at the specified location.\nThe location spans column ",(0,c.jsx)(n.code,{children:"startcolumn"})," of line ",(0,c.jsx)(n.code,{children:"startline"})," to column ",(0,c.jsx)(n.code,{children:"endcolumn"})," of line ",(0,c.jsx)(n.code,{children:"endline"})," in file ",(0,c.jsx)(n.code,{children:"filepath"}),". For more information, see\n",(0,c.jsx)(n.a,{href:"https://codeql.github.com/docs/writing-codeql-queries/providing-locations-in-codeql-queries/",children:"Locations"}),"."]}),"\n",(0,c.jsx)(n.p,{children:"Yields no result if this basic block spans multiple source files."}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"predicate hasLocationInfo(\n    string filepath, int startline, int startcolumn, int endline, int endcolumn\n  ) {\n    this.hasLocationInfoInternal(filepath, startline, startcolumn, filepath, endline, endcolumn)\n  }\n"})}),"\n",(0,c.jsx)(n.h3,{id:"haslocationinfointernalstring-file-int-line-int-col-string-endf-int-endl-int-endc",children:"hasLocationInfoInternal(string file, int line, int col, string endf, int endl, int endc)"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"  pragma[noinline]\n  private predicate hasLocationInfoInternal(\n    string file, int line, int col, string endf, int endl, int endc\n  ) {\n    this.getStart().getLocation().hasLocationInfo(file, line, col, _, _) and\n    this.getEnd().getLocation().hasLocationInfo(endf, _, _, endl, endc)\n  }\n"})}),"\n",(0,c.jsx)(n.h3,{id:"getenclosingfunction",children:"getEnclosingFunction()"}),"\n",(0,c.jsx)(n.p,{children:"Gets the function containing this basic block."}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"Solidity::FunctionDefinition getEnclosingFunction() {      result = this.getStart().getControlFlowScope() }\n"})}),"\n",(0,c.jsx)(n.h3,{id:"inloop",children:"inLoop()"}),"\n",(0,c.jsxs)(n.p,{children:["Holds if this basic block is in a loop of the control-flow graph. This includes loops created by ",(0,c.jsx)(n.code,{children:"goto"})," statements. This predicate may not hold\neven if this basic block is syntactically inside a ",(0,c.jsx)(n.code,{children:"while"})," loop if the necessary back edges are unreachable."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"predicate inLoop() { this.getASuccessor+() = this }\n"})}),"\n",(0,c.jsx)(n.h3,{id:"isreachable",children:"isReachable()"}),"\n",(0,c.jsxs)(n.p,{children:["Holds if control flow may reach this basic block from a function entry point or any handler of a reachable ",(0,c.jsx)(n.code,{children:"try"})," statement."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"predicate isReachable() {\n   \n    exists(Solidity::FunctionDefinition f | f.getBody() = this)\n    or\n    exists(BasicBlock pred | pred.getASuccessor() = this and pred.isReachable())\n}\n"})}),"\n",(0,c.jsx)(n.h3,{id:"isunreachable",children:"isUnreachable()"}),"\n",(0,c.jsxs)(n.p,{children:["Means ",(0,c.jsx)(n.code,{children:"not isReachable()"}),"."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"predicate isUnreachable() { not this.isReachable() }\n"})}),"\n",(0,c.jsx)(n.h2,{id:"entrybasicblock",children:"EntryBasicBlock"}),"\n",(0,c.jsx)(n.p,{children:"An entry point of a function."}),"\n",(0,c.jsx)(n.h3,{id:"entrybasicblock-1",children:"EntryBasicBlock()"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"EntryBasicBlock() { exists(Solidity::FunctionDefinition f | this = f.getBody()) }\n"})}),"\n",(0,c.jsx)(n.h2,{id:"exitbasicblock",children:"ExitBasicBlock"}),"\n",(0,c.jsx)(n.p,{children:"A basic block whose last node is the exit point of a function."}),"\n",(0,c.jsx)(n.h3,{id:"exitbasicblock-1",children:"ExitBasicBlock("}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"ExitBasicBlock() {\n    this.getEnd() instanceof Solidity::FunctionBody \n    // or\n    // aborting(this.getEnd())\n}\n"})}),"\n",(0,c.jsx)(n.h2,{id:"unreachablecontrolflownode-n",children:"unreachable(ControlFlowNode n)"}),"\n",(0,c.jsx)(n.p,{children:"Correct relation for reachability of ControlFlowNodes."}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"predicate unreachable(ControlFlowNode n) {\n  exists(BasicBlock bb | bb.contains(n) and bb.isUnreachable())\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(a,{...e})}):a(e)}},1503:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>r});var c=i(758);const s={},o=c.createContext(s);function l(e){const n=c.useContext(o);return c.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),c.createElement(o.Provider,{value:n},e.children)}}}]);